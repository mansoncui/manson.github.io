---
title: 正则表达式
date: 2019-06-11 16:47:00
tags:
    - [ 正则表达式 ]
categories:
    - [ 正则表达式 ]
---

## 正则表达式

##### 基本语法和案列
```
正则就是规则，正则表达式就是能够让我们表达出自己想法的规则

grep命令:
选项详解:
-i  区分大小写匹配
-n  显示行号
--color 或 --color=auto 高亮显示关键字
可以设置别名:alias grep='grep --color=auto'
-c 统计符合条件的总行数，而不打印出行
-o 只显示被匹配到的关键字，而不是讲整行内容都输出，一行匹配多个关键字会换行显示
-B 显示符合条件的行之前的行，“B” 有before之意
-B1 表示显示符合条件的同时还显示之前的1行
-B3 表示显示符合条件的同时还显示之前的3行

-A 和-B恰恰相反，-A有After之意
-w 有word之意，表示搜索的字符串作为一个独立的单词时才会被匹配到
-v 和匹配字符串取反的意思
-q 表示时静默模式，静默模式下grep不会输出任何信息，无论是否匹配到指定字符串，都不会
输出任何字符串，都不会输出任何信息
-E 扩展正则表达式

"^" 在正则中表示锚定行首
"$" 在正则中表示锚定行尾
"^$" 在正则中表示空行

案列:
[root@test-service ~]# grep "^hello" --color  test2 #显示已hello开头行
hello world
hello.cbb
hello
[root@test-service ~]# grep -n "^hello" --color  test2 #显示已hello开头的行并显示行号
1:hello world
3:hello.cbb
4:hello
[root@test-service ~]# grep -n  "^$" --color  test2  #显示空行和空行行号
4:
6:

"\<"表示锚定词首，"\>"表示锚定词尾
"\<与\>" 一起使用,也可以使用\b 锚定词首和词尾
案列:
[root@test-service ~]# cat test3 
hello world
hi		hello111111
hello.cbb

11111hello

[root@test-service ~]# grep --color "\<hello" test3
hello world
hi		hello111111
hello.cbb
[root@test-service ~]# grep --color "hello\>" test3
hello world
hello.cbb
11111hello
[root@test-service ~]# grep --color "\<hello\>" test3
hello world
hello.cbb

使用\b 锚定词首和词尾
案列:
[root@test-service ~]# grep --color "\bhello" test3
hello world
hi		hello111111
hello.cbb
[root@test-service ~]# grep --color "hello\b" test3
hello world
hello.cbb
11111hello
[root@test-service ~]# grep --color "\bhello\b" test3
hello world
hello.cbb

\B 是用来匹配非单词边界的
案列:
[root@test-service ~]# grep --color "\Bhello" test3  #只要hello不是词首，就会被匹配到,和"\bhello"恰恰相反
11111hello
[root@test-service ~]# grep --color "hello\B" test3  #只要hello不是词尾就匹配
hi		hello111111
[root@test-service ~]# grep --color "\Bhello\B" test3 #既不是词首也不是词尾，就匹配
1111hellocbb

总结:
^: 表示锚定行首,此字符后面的任意内容必须出现在行首，才能匹配
$: 表示锚定行尾,此字符前面的任意内容必须出现在行尾，才能匹配
^$: 表示匹配空行,这里所描述的空行表示“回车”，而“空格”或"tab"等都不能算此处所描述的空行
^abc$: 表示abc独占一行，会被匹配到
\<h或者\b :匹配单词边界，表示锚定词首，其后面的字符必须作为单词首部出现
\>或者\b ：匹配单词边界，表示锚定词尾，其前面的字符必须作为单词尾部出现
\B: 匹配非单词边界，与\b 正好相反
```

##### 正则表达式之分组
```
正则表达式之分组:

案列:
[root@test-service ~]# cat test5
abefef
abefefabefef
[root@test-service ~]# grep -n --color "\(abefef\)\{2\}" test5 #{2}是影响括号中一整个字符串
2:abefefabefef
[root@test-service ~]# grep -n --color "\(ab\(ef\)\{2\}\)\{2\}" test5
2:abefefabefef
以上案列中包含了两组分组符号，最外侧的"\( \)"中又包含了另一个"\( \)",这就是分组符号的嵌套

后向引用:
案列:
[root@test-service ~]# cat test6
Hello world Hello
Hiiii world Hiiii

[root@test-service ~]# grep --color "H.\{4\} world H.\{4\}" test6 
Hello world Hello
Hiiii world Hiiii

#第三行是新增也匹配
[root@test-service ~]# grep --color "H.\{4\} world H.\{4\}" test6 
Hello world Hello
Hiiii world Hiiii
Hello world Hiiii

#后向应用:在原有的基础之上新增分组
[root@test-service ~]# grep --color "\(H.\{4\}\) world \1" test6 
Hello world Hello
Hiiii world Hiiii

小结:
"\1"表示引用整个正则中第一个分组中的正则所匹配到的结果
"\2"表示引用整个正则中第二个分组中的正则所匹配到的结果

\(\)表示分组，我们可以将其中的内容当做一个整体，分组可以嵌套
\(ab\)表示将ab当做一个整体去处理

```
##### awk 格式化
```
主义以下三点:格式化printf和awk中printf不同
1）使用printf动作输出的文本不会换行，如果需要换行，可以在对应的"格式替换符"后加入"\n"进行转义。
2）使用printf动作时，"指定的格式" 与 "被格式化的文本" 之间，需要用"逗号"隔开。
3）使用printf动作时，"格式"中的"格式替换符"必须与 "被格式化的文本" 一一对应

案列:
[root@test-service ~]# awk -F: '{printf "%s\n%s\n%s\n" , $1,$2,$3}' test
root
x
0
bin
x
1

对比以下两个案列不同:
[root@test-service ~]# awk -F: '{printf "%s\n" , $1,$2}' test
root
bin
[root@test-service ~]# awk -F: '{printf "%s\n%s\n" , $1,$2}' test
root
x
bin
x

案列:设置变量指定分隔符
[root@test-service ~]# cat test
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
[root@test-service ~]# awk -v FS=':' '{printf "第一列: %s\t 第二列: %s\n" , $1,$2}' test
第一列: root	 第二列: x
第一列: bin	 第二列: x

[root@test-service ~]# awk -v FS=':' 'BEGIN{printf "%-10s\t %s\n" , "username","userid"} {printf "%-10s\t %s\n" , $1,$2}' test
username  	 userid
root      	 x
bin       	 x
```

##### awk 分隔符
```
输入分隔符，英文原文为field separator，此处简称为FS
输入分割符，默认是空白字符(即空格)，awk默认以空白字符为分隔符对每一行进行分割。

输出分割符，英文原文为output field separator，此处简称为OFS
awk将每行分割后，输出在屏幕上的时候，以什么字符作为分隔符，awk默认的输出分割符也是空格。

除了使用 -F 选项指定输入分隔符，还能够通过设置内部变量的方式，指定awk的输入分隔符，awk内置变量FS可以用于指定输入分隔符，但是在使用变量时，需要使用-v选项，用于指定对应的变量，比如 -v FS='#'
案列:
awk -F: '{print $1,$2}' test

awk -v FS=':' '{print $1,$2}' test

总结:
而-F，就是options的一种，用于指定输入分隔符
-v也是options的一种，用于设置变量的值

案列:
awk -v FS=':' -v OFS='-----' '{print $1,$2}' test  #指定输入和输出分隔符，
-v 选项设置变量意思

在输出的时候，我们想要让两列合并在一起显示，不使用输出分隔符分开显示，该怎么做呢？
案列:
awk '{print $1$2}' test
awk '{print $1 $2}' test
```

##### awk 变量
```
参考网址:https://blog.csdn.net/liang5603/article/details/80855386
awk来说"变量"又分为"内置变量" 和 "自定义变量" , "输入分隔符FS"和"输出分隔符OFS"都属于内置变量
内置变量就是awk预定义好的、内置在awk内部的变量，而自定义变量就是用户定义的变量。

awk常用的内置变量以及其作用如下:
FS：输入字段分隔符， 默认为空白字符
OFS：输出字段分隔符， 默认为空白字符
RS：输入记录分隔符(输入换行符)， 指定输入时的换行符(RS是行输入分隔符)
ORS：输出记录分隔符（输出换行符），输出时用指定符号代替换行符(ORS是行输出分隔符)
NF：number of Field，当前行的字段的个数(即当前行被分割成了几列)，字段数量
NR：行号，当前处理的文本行的行号。
FNR：各文件分别计数的行号
FILENAME：当前文件名
ARGC：命令行参数的个数
ARGV：数组，保存的是命令行所给定的各参数

内置变量NR：
NR是统计文本中行数，NF统计文本中行的列数
案列:
awk -F: '{print NR,NF}' test

$0是打印一整行内容
案列:
awk -F: '{print NR,$0}' test 

细心如你一定注意到了一个细节，就是在打印 $0 , $1 , $2 这些内置变量的时候，都有使用到"$"符号，但是在调用 NR , NF 这些内置变量的时候，就没有使用"$"，如果你有点不习惯，那么可能是因为你已经习惯了使用bash的语法去使用变量，在bash中，我们在引用变量时，都会使用$符进行引用，但是在awk中，只有在引用$0、$1等内置变量的值的时候才会用到"$",引用其他变量时，不管是内置变量，还是自定义变量，都不使用"$",而是直接使用变量名

内置变量FNR
FNR是对多个文件显示行号时使用的，不然用NR对多个文件进行显示行号是按顺序显示的
案列:第一列显示是行号，用NR是按顺序显示，FNR是按每个文件单独显示
[root@test-service ~]# awk '{print NR,$0}' test test1  #
1 root:x:0:0:root:/root:/bin/bash
2 bin:x:1:1:bin:/bin:/sbin/nologin
3 root:x:0:0:root:/root:/bin/bash
4 bin:x:1:1:bin:/bin:/sbin/nologin

[root@test-service ~]# awk '{print FNR,$0}' test test1 
1 root:x:0:0:root:/root:/bin/bash
2 bin:x:1:1:bin:/bin:/sbin/nologin
1 root:x:0:0:root:/root:/bin/bash
2 bin:x:1:1:bin:/bin:/sbin/nologin

内置变量RS:是输入行分隔符(awk认为,每遇到一个':'，就换行)
案列:
[root@test-service ~]# awk -v RS=':' '{print NR,$0}' test1 #指定':'为换行符
1 root
2 x
bin
3 x

内置变量ORS:是输出行分割符(打印到屏幕进行分割)
案列:
[root@test-service ~]# awk  -v ORS='+++' '{print NR,$0}' test1 
1 root:x+++2 bin:x+++

内置变量FILENAME:显示文本的文件名
案列:第一列是文本的文件名，第二列是每个文本行号，第三列是文本每行内容
[root@test-service ~]# awk '{print FILENAME,FNR,$0}' test1 test
test1 1 root:x
test1 2 bin:x
test 1 root:x:0:0:root:/root:/bin/bash
test 2 bin:x:1:1:bin:/bin:/sbin/nologin

内置变量ARGC与ARGV
ARGC内置变量是命令行参数个数
ARGV内置变量表示的是一个数组，这个数组中保存的是命令行所给定的参数
案列:
[root@test-service ~]# awk 'BEGIN{print 1111}' test
1111
[root@test-service ~]# awk 'BEGIN{print 1111,ARGV[1]}' test
1111 test
[root@test-service ~]# awk 'BEGIN{print 1111,ARGV[1],ARGV[2]}' test test1 
1111 test test1
[root@test-service ~]# awk 'BEGIN{print 1111,ARGV[0],ARGV[1],ARGV[2]}' test test1 
1111 awk test test1
[root@test-service ~]# awk 'BEGIN{print 1111,ARGV[0],ARGV[1],ARGV[2],ARGC}' test test1 
1111 awk test test1 3

自定义变量
方法一: -v varname=value  变量名区分字符大小写
方法二: 在program中直接定义
案列:
[root@test-service ~]# awk -v myVar='testVar' 'BEGIN{print myVar}'
testVar
[root@test-service ~]# awk  'BEGIN{myvar="tttt";print myvar}'
tttt
[root@test-service ~]# abc=6666666
[root@test-service ~]# awk -v myVar=$abc 'BEGIN{print myVar}'
6666666
```

##### 正则表达式小节
```
#################常用符号#################
.   表示任意单个字符。
*  表示前面的字符连续出现任意次，包括0次。
.* 表示任意长度的任意字符，与通配符中的*的意思相同。
\  表示转义符，当与正则表达式中的符号结合时表示符号本身。
[  ]表示匹配指定范围内的任意单个字符。
[^  ]表示匹配指定范围外的任意单个字符。
 
#################单个字符匹配相关#################
[[:alpha:]]  表示任意大小写字母。
[[:lower:]]  表示任意小写字母。
[[:upper:]]  表示任意大写字母。
[[:digit:]]  表示0到9之间的任意单个数字（包括0和9）。
[[:alnum:]]  表示任意数字或字母。
[[:space:]]  表示任意空白字符，包括"空格"、"tab键"等。
[[:punct:]]  表示任意标点符号。
[^[:alpha:]]  表示单个非字母字符。
[^[:lower:]]  表示单个非小写字母字符。
[^[:upper:]]  表示单个非大写字母字符。
[^[:digit:]]  表示单个非数字字符。
[^[:alnum:]]  表示单个非数字非字母字符。
[^[:space:]]  表示单个非空白字符。
[^[:punct:]]  表示单个非标点符号字符。
[0-9]与[[:digit:]]等效。
[a-z]与[[:lower:]]等效。
[A-Z]与[[:upper:]]等效。
[a-zA-Z]与[[:alpha:]]等效。
[a-zA-Z0-9]与[[:alnum:]]等效。
[^0-9]与[^[:digit:]]等效。
[^a-z]与[^[:lower:]]等效。
[^A-Z]与[^[:upper:]]等效
[^a-zA-Z]与[^[:alpha:]]等效
[^a-zA-Z0-9]与[^[:alnum:]]等效
#简短格式并非所有正则表达式解析器都可以识别。
\d 表示任意单个0到9的数字。
\D 表示任意单个非数字字符。
\t 表示匹配单个横向制表符（相当于一个tab键）。
\s表示匹配单个空白字符，包括"空格"，"tab制表符"等。
\S表示匹配单个非空白字符。
 
#################次数匹配相关#################
\?  表示匹配其前面的字符0或1次
\+  表示匹配其前面的字符至少1次，或者连续多次，连续次数上不封顶。
\{n\} 表示前面的字符连续出现n次，将会被匹配到。
\{x,y\} 表示之前的字符至少连续出现x次，最多连续出现y次，都能被匹配到，换句话说，只要之前的字符连续出现的次数在x与y之间，即可被匹配到。
\{,n\} 表示之前的字符连续出现至多n次，最少0次，都会陪匹配到。
\{n,\}表示之前的字符连续出现至少n次，才会被匹配到。
 
#################位置边界匹配相关#################
^：表示锚定行首，此字符后面的任意内容必须出现在行首，才能匹配。
$：表示锚定行尾，此字符前面的任意内容必须出现在行尾，才能匹配。
^$：表示匹配空行，这里所描述的空行表示"回车"，而"空格"或"tab"等都不能算作此处所描述的空行。
^abc$：表示abc独占一行时，会被匹配到。
\<或者\b ：匹配单词边界，表示锚定词首，其后面的字符必须作为单词首部出现。
\>或者\b ：匹配单词边界，表示锚定词尾，其前面的字符必须作为单词尾部出现。
\B：匹配非单词边界，与\b正好相反。
 
#################分组与后向引用#################
\( \) 表示分组，我们可以将其中的内容当做一个整体，分组可以嵌套。
\(ab\) 表示将ab当做一个整体去处理。
\1 表示引用整个表达式中第1个分组中的正则匹配到的结果。
\2 表示引用整个表达式中第2个分组中的正则匹配到的结果。
```
##### 工具下载地址:
```
#对比文件工具
https://www.scootersoftware.com/download.php

##小乌龟（Tortoisegit）
https://tortoisegit.org/download/

##图片存放地址
https://sm.ms/
```
